# EspTouch概述

## 流程
1. 用户创建任务对象，其中包含参数对象、服务器对象和客户端对象
2. 设置超时时间与成功返回设备上限数值
3. 获取本地ip地址
4. 创建配网对象
5. 配网对象包含导向数据对象、主数据对象
6. 导向数据对象以固定格式生成，主要用于告知设备解析主数据时的一个参数
7. 主数据对象包含：总长度、密码长度、ssid的crckey、bssid的crckey、本机ip地址、密码内容和前面所有数据异或的校验位一个字节
8. 如果该ssid是隐藏ssid，则需要在总长度加上ssid的长度，以及主数据对象中包含ssid的数据
9. 将导向数据对象和主数据对象，以一定格式转化为两个byte数组
10. 使用服务器对象开启监听，设备回复的数据
11. 客户端对象开始循环发送导向数据和主数据，导向数据发两秒，主数据发四秒，六秒一个循环，直到收到回复或者超时
12. 如果超时还没有成功，则直接返回给用户失败
13. 如果服务器对象收到了设备返回的信息，则对比第一个字符与ssid拼接密码的字节长度加9是否相等
14. 如果不相等忽略，如果相等则解析出回复数据中的设备bssid和设备ip地址
15. 将获取到的所有设备的bssid和ip地址返回给用户
16. 清理资源

# 备注
1. 导向数据实际长度（数据长度+udp+ip层） - 数据长度 = 基准值（udp+ip层）
2. 将每个子数据对象变为六个字节的数据后，每两个字节合并成一个uint16的数据并且加上固定值40存起来
3. 发送完成导向数据后，每两个字节发送一个包

# 举例

## 已知：
* ssid = [1,2,3,4,5,6,7,8]
* password = [5,6,7,8,9,10,11]
* bssid = [12,13,14,15,16,17,18,19]
* ip = [20,21,22,23,24,25]

## 求：
* sendArray

## 解：

passwordLength = 7

ssidCrcKey = 28（crc值为假设）

bssidCrcKey = 45（crc值为假设）

ipLength = 6

ssidLength = 8

totalLength = 5 + passwordLength + ipLength = 18

_totlaLength = totalLength + ssidLength = 46

index dh dl ch cl（crc值为假设）

datacodes = [
    {
	   0,2,E,3,F
	},
	{
	   1,0,7,2,A
	},
	{
	   2,2,8,7,2
	},
	......
]

datacodes中的数据依次存放总长度值、密码长度、ssid的CrcKey、bssid的CrcKey、ip地址、密码内容、（ssid内容）、之前所有数据的校验和。

dcArrays = [
    00,23,01,00,00,EF,
    00,02,01,01,00,7A,
    00,27,01,02,00,82,
    ......
]

// 下面都是16进制

_dcArrays = [{00,23},{01,00},{00,EF},{00,02},{01,01},{00,7A},{00,27},{01,02},{00,82},......];

## 答：
sendArray = [0023+28,0100+28,00EF+28,0002+28,0101+28,007A+28,0027+28,0102+28,0082+28,.....];

28 是一个固定值，代码中是十进制的40也就是0x28

导向数据发完后，sendArray中每个元素发一个数据包

